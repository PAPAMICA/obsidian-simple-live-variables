/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src-simple/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => LiveVariables
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src-simple/LiveVariablesSettings.ts
var DEFAULT_SETTINGS = {
  variableDelimiters: {
    start: "{{",
    end: "}}"
  },
  highlightDynamicVariables: true,
  dynamicVariableColor: "#ff9500",
  language: "en"
};

// src-simple/LiveVariablesSettingTab.tsx
var import_obsidian = require("obsidian");

// src-simple/i18n.ts
var en = {
  settings: {
    language: {
      name: "Language",
      desc: "Change the language of the plugin"
    },
    delimiters: {
      name: "Variable delimiters",
      desc: "Set the delimiters for variables"
    },
    highlight: {
      name: "Highlight dynamic variables",
      desc: "Highlight variables with a color to distinguish them from normal text"
    },
    color: {
      name: "Highlight color",
      desc: "Choose the color for highlighted variables"
    }
  },
  commands: {
    insertVariable: "Insert variable"
  },
  ui: {
    editVariable: "Edit variable",
    cancel: "Cancel",
    save: "Save",
    newValue: "New value",
    noVariables: "No variables available. Add variables in the YAML frontmatter.",
    selectVariable: "Select a variable",
    variableUpdated: "Variable updated",
    updateError: "Error updating variable",
    searchVariable: "Search variable..."
  }
};
var fr = {
  settings: {
    language: {
      name: "Langue",
      desc: "Changer la langue du plugin"
    },
    delimiters: {
      name: "D\xE9limiteurs de variables",
      desc: "D\xE9finir les d\xE9limiteurs pour les variables"
    },
    highlight: {
      name: "Surligner les variables dynamiques",
      desc: "Surligner les variables avec une couleur pour les distinguer du texte normal"
    },
    color: {
      name: "Couleur de surlignage",
      desc: "Choisir la couleur pour les variables surlign\xE9es"
    }
  },
  commands: {
    insertVariable: "Ins\xE9rer une variable"
  },
  ui: {
    editVariable: "Modifier la variable",
    cancel: "Annuler",
    save: "Enregistrer",
    newValue: "Nouvelle valeur",
    noVariables: "Aucune variable disponible. Ajoutez des variables dans le frontmatter YAML.",
    selectVariable: "S\xE9lectionner une variable",
    variableUpdated: "Variable mise \xE0 jour",
    updateError: "Erreur lors de la mise \xE0 jour de la variable",
    searchVariable: "Rechercher une variable..."
  }
};
function getTranslations(language) {
  return language === "en" ? en : fr;
}

// src-simple/LiveVariablesSettingTab.tsx
var LiveVariablesSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    const t = getTranslations(this.plugin.settings.language);
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName(t.settings.language.name).setDesc(t.settings.language.desc).addDropdown((dropdown) => {
      dropdown.addOption("en", "English").addOption("fr", "Fran\xE7ais").setValue(this.plugin.settings.language).onChange(async (value) => {
        this.plugin.settings.language = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    new import_obsidian.Setting(containerEl).setName(t.settings.delimiters.name).setDesc(t.settings.delimiters.desc).addText(
      (text) => text.setPlaceholder("{{").setValue(this.plugin.settings.variableDelimiters.start).onChange(async (value) => {
        this.plugin.settings.variableDelimiters.start = value;
        await this.plugin.saveSettings();
      })
    ).addText(
      (text) => text.setPlaceholder("}}").setValue(this.plugin.settings.variableDelimiters.end).onChange(async (value) => {
        this.plugin.settings.variableDelimiters.end = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName(t.settings.highlight.name).setDesc(t.settings.highlight.desc).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.highlightDynamicVariables).onChange(async (value) => {
        this.plugin.settings.highlightDynamicVariables = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName(t.settings.color.name).setDesc(t.settings.color.desc).addColorPicker(
      (colorPicker) => colorPicker.setValue(this.plugin.settings.dynamicVariableColor).onChange(async (value) => {
        this.plugin.settings.dynamicVariableColor = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// src-simple/VaultProperties.ts
var fs = __toESM(require("fs"));
var path = __toESM(require("path"));

// src-simple/utils.ts
function stringifyIfObj(obj) {
  if (obj === null) return "null";
  if (obj === void 0) return "undefined";
  if (typeof obj === "object") {
    try {
      return JSON.stringify(obj);
    } catch (e) {
      return String(obj);
    }
  }
  return String(obj);
}
function trancateString(str, maxLength) {
  if (str.length <= maxLength) return str;
  return str.substring(0, maxLength) + "...";
}

// src-simple/VaultProperties.ts
var VaultProperties = class {
  constructor(app) {
    this.temporaryVariables = /* @__PURE__ */ new Map();
    this.propertyChanged = (newProperties) => {
      var _a, _b;
      if (Object.entries((_a = this.localProperties) != null ? _a : {}).length !== Object.entries(newProperties != null ? newProperties : {}).length) {
        return true;
      }
      for (const [newPropKey, newPropVal] of Object.entries(
        newProperties != null ? newProperties : {}
      )) {
        if (typeof this.localProperties === "object") {
          const currentPropVal = (_b = this.localProperties) == null ? void 0 : _b[newPropKey];
          if (JSON.stringify(currentPropVal) !== JSON.stringify(newPropVal)) {
            return true;
          }
        }
      }
      return false;
    };
    this.app = app;
    this.vaultBasePath = app.vault.adapter.getBasePath();
    this.updateVaultProperties();
  }
  updateVaultProperties() {
    this.properties = this.getDirectoryTree(this.vaultBasePath);
  }
  updateProperties(file) {
    this.updateVaultProperties();
    this.localProperties = this.getValueByPath(this.properties, file.path);
    this.updateLocalKeysAndAllVariableKeys();
  }
  getDirectoryTree(dirPath) {
    const result = {};
    const items = fs.readdirSync(dirPath);
    for (const item of items) {
      if (item.startsWith(".obsidian")) continue;
      const fullPath = path.join(dirPath, item);
      const stats = fs.statSync(fullPath);
      if (stats.isDirectory()) {
        result[item] = this.getDirectoryTree(fullPath);
      } else if (path.extname(item) === ".md") {
        result[item] = this.getMarkdownProperties(fullPath);
      }
    }
    return result;
  }
  getMarkdownProperties(markdownAbsoluteFilePath) {
    var _a, _b;
    const vaultPath = path.posix.join(...this.vaultBasePath.split(path.sep)) + "/";
    const markdownFilePath = path.posix.join(...markdownAbsoluteFilePath.split(path.sep)).slice(vaultPath.length);
    const file = this.app.vault.getFileByPath(markdownFilePath);
    if (file) {
      return (_b = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter) != null ? _b : {};
    }
    return {};
  }
  getLocalProperty(key) {
    return this.getValueByPath(this.localProperties, key);
  }
  getProperty(path2) {
    var _a, _b;
    if (this.temporaryVariables.has(path2)) {
      return this.temporaryVariables.get(path2);
    }
    const currentFile = this.app.workspace.getActiveFile();
    if (!currentFile) return void 0;
    if (path2.includes("/")) {
      const [filePath, propPath] = path2.split("/");
      const file = this.app.vault.getFileByPath(filePath);
      if (!file) return void 0;
      const frontmatter2 = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
      if (!frontmatter2) return void 0;
      return this.getValueByPath(frontmatter2, propPath);
    }
    const frontmatter = (_b = this.app.metadataCache.getFileCache(currentFile)) == null ? void 0 : _b.frontmatter;
    if (!frontmatter) return void 0;
    return this.getValueByPath(frontmatter, path2);
  }
  getLocalProperties() {
    return this.localProperties;
  }
  getValueByPath(obj, path2) {
    if (!obj || !path2) return void 0;
    const keys = path2.split(".");
    return keys.reduce((acc, key) => {
      if (acc && typeof acc === "object" && acc.hasOwnProperty(key)) {
        return acc[key];
      }
      return void 0;
    }, obj);
  }
  getAllVariableKeys() {
    return this.getAllPaths(this.properties);
  }
  findPropertiesWithPathContaining(searchPath) {
    return this.findPathsContaining(searchPath).map((key) => ({
      key,
      value: stringifyIfObj(this.getProperty(key))
    }));
  }
  findLocalPropertiesWithPathContaining(file, searchPath) {
    return this.findLocalPathsContaining(searchPath).map((key) => ({
      key,
      value: stringifyIfObj(this.getProperty(key))
    }));
  }
  findLocalPathsContaining(searchPath) {
    if (searchPath.length === 0) {
      return this.getLocalKeys();
    }
    return this.getLocalKeys().filter((path2) => path2.contains(searchPath));
  }
  findPathsContaining(searchPath) {
    if (searchPath.length === 0) {
      return this.getLocalKeysAndAllVariableKeys();
    }
    return this.getLocalKeysAndAllVariableKeys().filter(
      (path2) => path2.contains(searchPath)
    );
  }
  findPathsStartingWith(searchPath) {
    if (searchPath.length === 0) {
      return this.getLocalKeysAndAllVariableKeys();
    }
    return this.getLocalKeysAndAllVariableKeys().filter(
      (path2) => path2.startsWith(searchPath)
    );
  }
  updateLocalKeysAndAllVariableKeys() {
    this.localKeys = this.getAllPaths(this.getLocalProperties(), "", true);
    this.localKeysAndAllVariableKeys = [
      ...this.localKeys,
      ...this.getAllPaths(this.properties)
    ];
  }
  getLocalKeysAndAllVariableKeys() {
    return this.localKeysAndAllVariableKeys;
  }
  getLocalKeys() {
    return this.localKeys;
  }
  getAllPaths(obj, parentPath = "", local) {
    const isNestedProperty = parentPath.contains(".md/") || local;
    const separator = isNestedProperty ? "." : "/";
    let paths = [];
    for (const [key, value] of Object.entries(obj != null ? obj : {})) {
      const fullPath = parentPath ? `${parentPath}${separator}${key}` : key;
      paths.push(fullPath);
      if (typeof value === "object") {
        paths = [...paths, ...this.getAllPaths(value, fullPath, local)];
      }
    }
    return paths;
  }
  getPropertyPreview(path2) {
    const value = this.getProperty(path2);
    return value ? trancateString(stringifyIfObj(value), 50) : "no value";
  }
  // Méthode pour mettre à jour une variable (temporaire et permanente)
  async temporaryUpdateVariable(path2, value) {
    this.temporaryVariables.set(path2, value);
    const currentFile = this.app.workspace.getActiveFile();
    if (currentFile) {
      try {
        if (path2.includes("/")) {
          const [filePath, propPath] = path2.split("/");
          const targetFile = this.app.vault.getFileByPath(filePath);
          if (targetFile) {
            await this.updateFrontmatterProperty(targetFile, propPath, value);
          }
        } else {
          await this.updateFrontmatterProperty(currentFile, path2, value);
        }
      } catch (error) {
        console.error("Erreur lors de la mise \xE0 jour du frontmatter:", error);
        throw error;
      }
    }
    console.log(`Variable ${path2} mise \xE0 jour avec la valeur ${value}`);
  }
  // Méthode pour mettre à jour une propriété dans le frontmatter d'un fichier
  async updateFrontmatterProperty(file, propertyPath, value) {
    try {
      const fileContent = await this.app.vault.read(file);
      if (!fileContent.startsWith("---")) {
        const formattedValue = this.formatValueForYaml(value);
        const newFileContent = `---
${propertyPath}: ${formattedValue}
---

${fileContent}`;
        await this.app.vault.modify(file, newFileContent);
        console.log(`Nouveau frontmatter cr\xE9\xE9 avec la propri\xE9t\xE9 ${propertyPath} dans ${file.path}`);
        return;
      }
      const endOfFrontmatter = fileContent.indexOf("---", 3);
      if (endOfFrontmatter === -1) {
        const formattedValue = this.formatValueForYaml(value);
        const newFileContent = `---
${propertyPath}: ${formattedValue}
---

${fileContent.substring(3)}`;
        await this.app.vault.modify(file, newFileContent);
        console.log(`Frontmatter r\xE9par\xE9 avec la propri\xE9t\xE9 ${propertyPath} dans ${file.path}`);
        return;
      }
      const frontmatter = fileContent.substring(3, endOfFrontmatter).trim();
      const restOfFile = fileContent.substring(endOfFrontmatter);
      if (!propertyPath.includes(".")) {
        const regex = new RegExp(`^${propertyPath}\\s*:.*$`, "m");
        const match = frontmatter.match(regex);
        let newFrontmatter;
        if (match) {
          const formattedValue = this.formatValueForYaml(value);
          newFrontmatter = frontmatter.replace(
            regex,
            `${propertyPath}: ${formattedValue}`
          );
        } else {
          const formattedValue = this.formatValueForYaml(value);
          newFrontmatter = `${frontmatter}
${propertyPath}: ${formattedValue}`;
        }
        const newFileContent = `---
${newFrontmatter}
${restOfFile}`;
        await this.app.vault.modify(file, newFileContent);
        console.log(`Propri\xE9t\xE9 ${propertyPath} mise \xE0 jour dans ${file.path}`);
      } else {
        const [parent, child] = propertyPath.split(".");
        if (child) {
          const parentRegex = new RegExp(`^${parent}\\s*:.*$`, "m");
          const parentMatch = frontmatter.match(parentRegex);
          let newFrontmatter;
          if (parentMatch) {
            const parentLine = parentMatch[0];
            const indentedRegex = new RegExp(`^(\\s+)${child}\\s*:.*$`, "m");
            const indentedMatch = frontmatter.match(indentedRegex);
            if (indentedMatch) {
              const formattedValue = this.formatValueForYaml(value);
              newFrontmatter = frontmatter.replace(
                indentedRegex,
                `${indentedMatch[1]}${child}: ${formattedValue}`
              );
            } else {
              if (parentLine.trim().endsWith(":")) {
                const formattedValue = this.formatValueForYaml(value);
                newFrontmatter = frontmatter.replace(
                  parentRegex,
                  `${parentMatch[0]}
  ${child}: ${formattedValue}`
                );
              } else {
                const formattedValue = this.formatValueForYaml(value);
                newFrontmatter = frontmatter.replace(
                  parentRegex,
                  `${parent}:
  ${child}: ${formattedValue}`
                );
              }
            }
          } else {
            const formattedValue = this.formatValueForYaml(value);
            newFrontmatter = `${frontmatter}
${parent}:
  ${child}: ${formattedValue}`;
          }
          const newFileContent = `---
${newFrontmatter}
${restOfFile}`;
          await this.app.vault.modify(file, newFileContent);
          console.log(`Propri\xE9t\xE9 imbriqu\xE9e ${propertyPath} mise \xE0 jour dans ${file.path}`);
        } else {
          console.log(`Propri\xE9t\xE9 imbriqu\xE9e ${propertyPath} mal form\xE9e`);
        }
      }
    } catch (error) {
      console.error("Erreur lors de la mise \xE0 jour du frontmatter:", error);
      throw error;
    }
  }
  // Formater une valeur pour YAML
  formatValueForYaml(value) {
    if (typeof value === "string") {
      if (value.match(/[:#\[\]{},%&*()='"|><]/)) {
        const escapedValue = value.replace(/"/g, '\\"');
        return `"${escapedValue}"`;
      }
      return value;
    } else if (typeof value === "number" || typeof value === "boolean") {
      return value.toString();
    } else if (value === null || value === void 0) {
      return "null";
    } else {
      try {
        return JSON.stringify(value);
      } catch (e) {
        return String(value);
      }
    }
  }
};

// src-simple/main.ts
var LiveVariables = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.styleElement = null;
    this.activeTooltip = null;
    // Handle clicks outside the tooltip to close it
    this.handleClickOutside = (e) => {
      if (this.activeTooltip && e.target && !this.activeTooltip.contains(e.target)) {
        this.closeActiveTooltip();
      }
    };
  }
  async onload() {
    await this.loadSettings();
    this.vaultProperties = new VaultProperties(this.app);
    this.addCommand({
      id: "insert-variable",
      name: getTranslations(this.settings.language).commands.insertVariable,
      editorCallback: (editor, view) => {
        var _a;
        if (!view) return;
        const variables = [];
        const currentFile = view.file;
        if (currentFile) {
          const frontmatter = (_a = this.app.metadataCache.getFileCache(currentFile)) == null ? void 0 : _a.frontmatter;
          if (frontmatter) {
            Object.keys(frontmatter).forEach((key) => {
              variables.push({
                key,
                value: frontmatter[key]
              });
            });
          }
        }
        const t = getTranslations(this.settings.language);
        if (variables.length === 0) {
          new import_obsidian2.Notice(t.ui.noVariables);
          return;
        }
        const modal = new VariableSelectionModal(
          this.app,
          variables,
          (variable) => {
            const variableText = `${this.settings.variableDelimiters.start}${variable.key}${this.settings.variableDelimiters.end}`;
            editor.replaceSelection(variableText);
          },
          this.settings.language
        );
        modal.open();
      }
    });
    this.addSettingTab(new LiveVariablesSettingTab(this.app, this));
    this.addStylesheet(`
			.dynamic-variable {
				color: ${this.settings.dynamicVariableColor} !important;
				display: inline !important;
				background: none !important;
				padding: 0 !important;
				margin: 0 !important;
				border: none !important;
				font-weight: inherit !important;
				font-style: inherit !important;
				font-size: inherit !important;
				font-family: inherit !important;
				line-height: inherit !important;
				text-decoration: inherit !important;
				pointer-events: inherit !important;
				cursor: pointer !important;
				position: relative;
				border-bottom: 1px dotted ${this.settings.dynamicVariableColor} !important;
			}
			
			.dynamic-variable:hover {
				background-color: rgba(0, 0, 0, 0.1) !important;
			}
			
			.variable-edit-tooltip {
				position: absolute;
				z-index: 1000;
				background-color: var(--background-primary);
				border: 1px solid var(--background-modifier-border);
				border-radius: 4px;
				padding: 8px;
				box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
				min-width: 200px;
				font-family: var(--font-interface);
			}
			
			.variable-edit-tooltip h5 {
				margin: 0 0 8px 0;
				font-size: 14px;
				font-weight: 600;
				color: var(--text-normal);
			}
			
			.variable-edit-tooltip input {
				width: 100%;
				margin-bottom: 8px;
				background-color: var(--background-primary);
				border: 1px solid var(--background-modifier-border);
				color: var(--text-normal);
				padding: 4px 8px;
				border-radius: 4px;
			}
			
			.variable-edit-tooltip .tooltip-buttons {
				display: flex;
				justify-content: flex-end;
				gap: 8px;
			}
			
			.variable-edit-tooltip button {
				padding: 4px 8px;
				background-color: var(--interactive-normal);
				border: 1px solid var(--background-modifier-border);
				border-radius: 4px;
				color: var(--text-normal);
				cursor: pointer;
				font-size: 12px;
			}
			
			.variable-edit-tooltip button.primary {
				background-color: var(--interactive-accent);
				color: var(--text-on-accent);
			}
			
			.variable-edit-tooltip button:hover {
				background-color: var(--interactive-hover);
			}
			
			.variable-edit-tooltip button.primary:hover {
				background-color: var(--interactive-accent-hover);
			}
		`);
    this.registerMarkdownPostProcessor((element) => {
      const walker = document.createTreeWalker(
        element,
        NodeFilter.SHOW_TEXT,
        null
      );
      let node;
      const nodesToReplace = [];
      while (node = walker.nextNode()) {
        const text = node.textContent || "";
        const startDelimiter = this.settings.variableDelimiters.start;
        const endDelimiter = this.settings.variableDelimiters.end;
        const regex = new RegExp(`${startDelimiter}(.*?)${endDelimiter}`, "g");
        let modified = false;
        let newText = text;
        [...text.matchAll(regex)].forEach((match) => {
          const variable = match[1];
          const value = this.vaultProperties.getProperty(variable);
          if (value !== void 0) {
            const stringValue = this.stringifyValue(value);
            const displayValue = this.settings.highlightDynamicVariables ? `<span class="dynamic-variable" data-variable="${variable}">${stringValue}</span>` : stringValue;
            newText = newText.replace(match[0], displayValue);
            modified = true;
          }
        });
        if (modified) {
          nodesToReplace.push({ node, newContent: newText });
        }
      }
      nodesToReplace.forEach(({ node: node2, newContent }) => {
        var _a;
        const tempDiv = document.createElement("div");
        tempDiv.innerHTML = newContent;
        const fragment = document.createDocumentFragment();
        while (tempDiv.firstChild) {
          fragment.appendChild(tempDiv.firstChild);
        }
        (_a = node2.parentNode) == null ? void 0 : _a.replaceChild(fragment, node2);
      });
      this.setupVariableEditHandlers(element);
      this.modifyCodeBlockCopyButtons(element);
    });
    this.registerEvents();
  }
  // Register all event handlers
  registerEvents() {
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        this.vaultProperties.updateProperties(file);
        const view = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
        if (view && view.file === file) {
          if (view.getMode() === "preview") {
            view.previewMode.rerender();
          } else {
            view.editor.refresh();
          }
          this.app.workspace.trigger("resize");
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("layout-change", () => {
        this.app.workspace.iterateRootLeaves((leaf) => {
          if (leaf.view instanceof import_obsidian2.MarkdownView && leaf.view.getMode() === "preview") {
            this.modifyCodeBlockCopyButtons(leaf.view.containerEl);
          }
        });
      })
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", (leaf) => {
        if ((leaf == null ? void 0 : leaf.view) instanceof import_obsidian2.MarkdownView && leaf.view.getMode() === "preview") {
          setTimeout(() => {
            this.modifyCodeBlockCopyButtons(leaf.view.containerEl);
          }, 100);
        }
      })
    );
  }
  // Set up click handlers for editing variables
  setupVariableEditHandlers(element) {
    const variables = element.querySelectorAll(".dynamic-variable");
    variables.forEach((varEl) => {
      varEl.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        const variable = varEl.getAttribute("data-variable");
        if (!variable) return;
        const currentValue = this.vaultProperties.getProperty(variable) || "";
        this.showVariableEditTooltip(varEl, variable, currentValue.toString());
      });
    });
  }
  // Create and show the variable edit tooltip
  showVariableEditTooltip(element, variable, currentValue) {
    this.closeActiveTooltip();
    const t = getTranslations(this.settings.language);
    const tooltip = document.createElement("div");
    tooltip.className = "variable-edit-tooltip";
    tooltip.innerHTML = `
			<h5>${t.ui.editVariable}: ${variable}</h5>
			<input type="text" value="${currentValue.replace(/"/g, "&quot;")}" placeholder="${t.ui.newValue}" />
			<div class="tooltip-buttons">
				<button class="cancel">${t.ui.cancel}</button>
				<button class="primary save">${t.ui.save}</button>
			</div>
		`;
    const rect = element.getBoundingClientRect();
    tooltip.style.left = `${rect.left}px`;
    tooltip.style.top = `${rect.bottom + 5}px`;
    const inputEl = tooltip.querySelector("input");
    const cancelBtn = tooltip.querySelector("button.cancel");
    const saveBtn = tooltip.querySelector("button.primary");
    if (inputEl && cancelBtn && saveBtn) {
      setTimeout(() => {
        inputEl.focus();
        inputEl.select();
      }, 10);
      cancelBtn.addEventListener("click", () => {
        this.closeActiveTooltip();
      });
      saveBtn.addEventListener("click", async () => {
        const newValue = inputEl.value;
        await this.updateVariableValue(variable, newValue);
        this.closeActiveTooltip();
      });
      inputEl.addEventListener("keydown", async (e) => {
        if (e.key === "Enter") {
          const newValue = inputEl.value;
          await this.updateVariableValue(variable, newValue);
          this.closeActiveTooltip();
        } else if (e.key === "Escape") {
          this.closeActiveTooltip();
        }
      });
      document.addEventListener("click", this.handleClickOutside);
    }
    document.body.appendChild(tooltip);
    this.activeTooltip = tooltip;
  }
  // Close the active tooltip
  closeActiveTooltip() {
    if (this.activeTooltip) {
      document.removeEventListener("click", this.handleClickOutside);
      this.activeTooltip.remove();
      this.activeTooltip = null;
    }
  }
  // Update a variable value and refresh all instances
  async updateVariableValue(variable, newValue) {
    const t = getTranslations(this.settings.language);
    try {
      await this.vaultProperties.temporaryUpdateVariable(variable, newValue);
      new import_obsidian2.Notice(`${t.ui.variableUpdated}: "${variable}"`);
      const activeLeaf = this.app.workspace.activeLeaf;
      if ((activeLeaf == null ? void 0 : activeLeaf.view) instanceof import_obsidian2.MarkdownView && activeLeaf.view.file) {
        this.refreshView(activeLeaf.view.file);
        setTimeout(() => {
          if (activeLeaf.view instanceof import_obsidian2.MarkdownView) {
            const view = activeLeaf.view;
            if (view.getMode() === "preview") {
              view.previewMode.rerender(true);
              setTimeout(() => {
                this.updateCodeBlocksWithVariables(view);
                this.setupVariableEditHandlers(view.containerEl);
                this.modifyCodeBlockCopyButtons(view.containerEl);
              }, 100);
            }
            this.app.workspace.trigger("live-variables:variable-updated", variable, newValue);
          }
        }, 50);
      }
      this.app.workspace.iterateRootLeaves((leaf) => {
        if (leaf !== this.app.workspace.activeLeaf && leaf.view instanceof import_obsidian2.MarkdownView && leaf.view.file) {
          this.refreshView(leaf.view.file);
        }
      });
      setTimeout(() => {
        this.forceGlobalRefresh();
      }, 200);
    } catch (error) {
      console.error(`${t.ui.updateError}:`, error);
      new import_obsidian2.Notice(`${t.ui.updateError}: ${error.message}`);
    }
  }
  // Force a global refresh of all views
  forceGlobalRefresh() {
    this.app.workspace.trigger("resize");
    this.vaultProperties.updateVaultProperties();
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view instanceof import_obsidian2.MarkdownView) {
        if (leaf.view.getMode() === "preview") {
          leaf.view.previewMode.rerender(true);
        } else {
          leaf.view.editor.refresh();
        }
      }
    });
  }
  // Refresh a specific view
  refreshView(file) {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    if (view && view.file === file) {
      this.vaultProperties.updateProperties(file);
      if (view.getMode() === "preview") {
        view.previewMode.rerender(true);
        setTimeout(() => {
          this.updateCodeBlocksWithVariables(view);
          this.setupVariableEditHandlers(view.contentEl);
          this.modifyCodeBlockCopyButtons(view.contentEl);
          this.app.workspace.trigger("resize");
        }, 100);
      } else {
        view.editor.refresh();
        this.app.workspace.trigger("resize");
      }
    } else {
      let foundView = false;
      this.app.workspace.iterateAllLeaves((leaf) => {
        if (!foundView && leaf.view instanceof import_obsidian2.MarkdownView && leaf.view.file === file) {
          foundView = true;
          this.vaultProperties.updateProperties(file);
          if (leaf.view.getMode() === "preview") {
            leaf.view.previewMode.rerender(true);
            setTimeout(() => {
              this.updateCodeBlocksWithVariables(leaf.view);
              if (leaf.view instanceof import_obsidian2.MarkdownView) {
                this.setupVariableEditHandlers(leaf.view.containerEl);
                this.modifyCodeBlockCopyButtons(leaf.view.containerEl);
              }
            }, 100);
          } else {
            leaf.view.editor.refresh();
          }
        }
      });
    }
  }
  // Update code blocks with variables
  updateCodeBlocksWithVariables(view) {
    const codeBlocks = view.contentEl.querySelectorAll("pre code");
    codeBlocks.forEach((codeBlock) => {
      const originalCode = codeBlock.getAttribute("data-original-code");
      if (originalCode) {
        const variables = JSON.parse(codeBlock.getAttribute("data-variables") || "[]");
        if (variables.length > 0) {
          const startDelimiter = this.settings.variableDelimiters.start;
          const endDelimiter = this.settings.variableDelimiters.end;
          let processedCode = originalCode;
          const escapeRegExp = (str) => str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          const startDelimiterEscaped = escapeRegExp(startDelimiter);
          const endDelimiterEscaped = escapeRegExp(endDelimiter);
          const variablePattern = `${startDelimiterEscaped}(${variables.join("|")})${endDelimiterEscaped}`;
          const regex = new RegExp(variablePattern, "g");
          processedCode = processedCode.replace(regex, (match, variable) => {
            const value = this.vaultProperties.getProperty(variable);
            if (value !== void 0) {
              const stringValue = this.stringifyValue(value);
              return this.settings.highlightDynamicVariables ? `<span class="dynamic-variable" data-variable="${variable}">${stringValue}</span>` : stringValue;
            }
            return match;
          });
          codeBlock.innerHTML = processedCode;
          this.setupVariableEditHandlers(codeBlock);
        }
      }
    });
  }
  // Convert any value to string
  stringifyValue(value) {
    if (value === null) return "null";
    if (value === void 0) return "undefined";
    if (typeof value === "object") {
      try {
        return JSON.stringify(value);
      } catch (e) {
        return String(value);
      }
    }
    return String(value);
  }
  // Override copy buttons in code blocks to copy variable values
  modifyCodeBlockCopyButtons(element) {
    const preElements = element.querySelectorAll("pre");
    preElements.forEach((preEl) => {
      const copyButton = preEl.querySelector(".copy-code-button");
      if (!copyButton) return;
      const codeEl = preEl.querySelector("code");
      if (!codeEl) return;
      if (!codeEl.hasAttribute("data-processed-text")) {
        const originalText = codeEl.textContent || "";
        codeEl.setAttribute("data-original-text", originalText);
        let processedText = this.processCodeText(originalText);
        const variables = codeEl.getAttribute("data-variables");
        const originalCode = codeEl.getAttribute("data-original-code");
        if (originalCode && variables) {
          let variableProcessed = originalCode;
          const variableArray = JSON.parse(variables);
          if (variableArray.length > 0) {
            const startDelimiter = this.settings.variableDelimiters.start;
            const endDelimiter = this.settings.variableDelimiters.end;
            variableArray.forEach((variable) => {
              const value = this.vaultProperties.getProperty(variable);
              if (value !== void 0) {
                const stringValue = this.stringifyValue(value);
                variableProcessed = variableProcessed.replace(
                  new RegExp(`${startDelimiter}${variable}${endDelimiter}`, "g"),
                  stringValue
                );
              }
            });
          }
          processedText = this.processCodeText(variableProcessed);
        }
        codeEl.setAttribute("data-processed-text", processedText);
      }
      copyButton.removeEventListener("click", this.getOriginalClickHandler(copyButton));
      copyButton.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        let renderedText = codeEl.getAttribute("data-processed-text") || codeEl.textContent || "";
        navigator.clipboard.writeText(renderedText).catch((error) => {
          console.error("Failed to copy text: ", error);
          new import_obsidian2.Notice("Failed to copy text");
        });
      });
    });
  }
  // Helper method to process code text and remove line numbers
  processCodeText(text) {
    const lines = text.split("\n");
    const fixedLines = lines.map((line) => {
      let processed = line.replace(/^(\d+)([a-zA-Z])/, "$2");
      if (processed.match(/\d+[a-zA-Z]/)) {
        processed = processed.replace(/(\d+)([a-zA-Z])/g, " $2");
      }
      return processed;
    });
    let processedText = fixedLines.join("\n");
    processedText = processedText.replace(/^\d+\s+/gm, "");
    return processedText;
  }
  // Helper method to get original click handler (placeholder)
  getOriginalClickHandler(element) {
    return () => {
    };
  }
  // Clean up on plugin unload
  onunload() {
    if (this.styleElement) {
      this.styleElement.remove();
      this.styleElement = null;
    }
    this.closeActiveTooltip();
  }
  // Helper method to add stylesheet
  addStylesheet(css) {
    const styleEl = document.createElement("style");
    styleEl.textContent = css;
    document.head.appendChild(styleEl);
    this.styleElement = styleEl;
  }
  // Load settings from storage
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  // Save settings to storage
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var VariableSelectionModal = class extends import_obsidian2.Modal {
  constructor(app, variables, onChoose, language) {
    super(app);
    this.variables = variables;
    this.displayedVariables = [...variables];
    this.onChoose = onChoose;
    this.language = language;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("variable-selection-modal");
    const t = getTranslations(this.language);
    const titleContainer = contentEl.createEl("div", { cls: "modal-title-container" });
    titleContainer.style.display = "flex";
    titleContainer.style.alignItems = "center";
    titleContainer.style.marginBottom = "16px";
    const iconSpan = titleContainer.createEl("span", { cls: "modal-title-icon" });
    iconSpan.innerHTML = `
			<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
				<path d="M6 16l-4-4 4-4"></path>
				<path d="M18 8l4 4-4 4"></path>
				<path d="M12 4l-4 16"></path>
			</svg>
		`;
    iconSpan.style.marginRight = "10px";
    iconSpan.style.display = "flex";
    iconSpan.style.alignItems = "center";
    iconSpan.style.color = "var(--interactive-accent)";
    titleContainer.createEl("h2", {
      text: t.ui.selectVariable,
      cls: "modal-title"
    }).style.margin = "0";
    const searchContainer = contentEl.createEl("div", { cls: "search-container" });
    searchContainer.style.position = "relative";
    searchContainer.style.marginBottom = "16px";
    const searchIconContainer = searchContainer.createEl("div", { cls: "search-icon" });
    searchIconContainer.innerHTML = `
			<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
				<circle cx="11" cy="11" r="8"></circle>
				<line x1="21" y1="21" x2="16.65" y2="16.65"></line>
			</svg>
		`;
    searchIconContainer.style.position = "absolute";
    searchIconContainer.style.left = "12px";
    searchIconContainer.style.top = "50%";
    searchIconContainer.style.transform = "translateY(-50%)";
    searchIconContainer.style.pointerEvents = "none";
    searchIconContainer.style.color = "var(--text-muted)";
    this.searchInput = searchContainer.createEl("input", {
      cls: "search-input",
      attr: {
        type: "text",
        placeholder: t.ui.searchVariable
      }
    });
    this.searchInput.style.width = "100%";
    this.searchInput.style.padding = "10px 12px 10px 40px";
    this.searchInput.style.fontSize = "14px";
    this.searchInput.style.borderRadius = "6px";
    this.searchInput.style.border = "1px solid var(--background-modifier-border)";
    this.searchInput.style.backgroundColor = "var(--background-secondary)";
    this.searchInput.style.color = "var(--text-normal)";
    this.searchInput.style.boxShadow = "inset 0 1px 4px rgba(0, 0, 0, 0.07)";
    setTimeout(() => this.searchInput.focus(), 10);
    const listContainer = contentEl.createEl("div", { cls: "variables-container" });
    listContainer.style.backgroundColor = "var(--background-secondary)";
    listContainer.style.borderRadius = "6px";
    listContainer.style.overflow = "hidden";
    listContainer.style.border = "1px solid var(--background-modifier-border)";
    const listHeader = listContainer.createEl("div", { cls: "variables-header" });
    listHeader.style.display = "flex";
    listHeader.style.padding = "8px 16px";
    listHeader.style.borderBottom = "1px solid var(--background-modifier-border)";
    listHeader.style.backgroundColor = "var(--background-secondary-alt)";
    listHeader.style.fontSize = "12px";
    listHeader.style.fontWeight = "bold";
    listHeader.style.color = "var(--text-muted)";
    listHeader.style.textTransform = "uppercase";
    const keyHeader = listHeader.createEl("div", { text: "Key", cls: "column-key" });
    keyHeader.style.flex = "1";
    const valueHeader = listHeader.createEl("div", { text: "Value", cls: "column-value" });
    valueHeader.style.flex = "1";
    this.variableList = listContainer.createEl("div", { cls: "variable-list" });
    this.variableList.style.maxHeight = "50vh";
    this.variableList.style.overflowY = "auto";
    this.searchInput.addEventListener("input", () => {
      this.filterVariables(this.searchInput.value);
    });
    this.searchInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        if (this.displayedVariables.length > 0) {
          e.preventDefault();
          this.onChoose(this.displayedVariables[0]);
          this.close();
        }
      } else if (e.key === "Escape") {
        e.preventDefault();
        this.close();
      } else if (e.key === "ArrowDown") {
        const firstItem = this.variableList.querySelector(".variable-item");
        if (firstItem) {
          e.preventDefault();
          firstItem.focus();
        }
      }
    });
    const footerEl = contentEl.createEl("div", { cls: "modal-footer" });
    footerEl.style.marginTop = "16px";
    footerEl.style.color = "var(--text-muted)";
    footerEl.style.fontSize = "12px";
    footerEl.style.display = "flex";
    footerEl.style.justifyContent = "space-between";
    const keyboardShortcuts = footerEl.createEl("div", { cls: "keyboard-shortcuts" });
    const addShortcut = (container, key, description) => {
      const shortcutEl = container.createEl("span", { cls: "keyboard-shortcut" });
      shortcutEl.style.display = "inline-flex";
      shortcutEl.style.alignItems = "center";
      shortcutEl.style.marginRight = "12px";
      const keyEl = shortcutEl.createEl("kbd");
      keyEl.style.background = "var(--background-primary)";
      keyEl.style.border = "1px solid var(--background-modifier-border)";
      keyEl.style.boxShadow = "0 1px 0 0 var(--background-modifier-border)";
      keyEl.style.borderRadius = "4px";
      keyEl.style.padding = "2px 6px";
      keyEl.style.fontSize = "11px";
      keyEl.style.margin = "0 4px";
      keyEl.textContent = key;
      const descEl = shortcutEl.createEl("span");
      descEl.textContent = description;
    };
    addShortcut(keyboardShortcuts, "\u2191\u2193", this.language === "en" ? "Navigate" : "Naviguer");
    addShortcut(keyboardShortcuts, "Enter", this.language === "en" ? "Select" : "S\xE9lectionner");
    addShortcut(keyboardShortcuts, "Esc", this.language === "en" ? "Cancel" : "Annuler");
    const countEl = footerEl.createEl("div", { cls: "variables-count" });
    countEl.textContent = `${this.variables.length} ${this.language === "en" ? "variables" : "variables"}`;
    this.renderVariableList();
  }
  filterVariables(query) {
    if (!query) {
      this.displayedVariables = [...this.variables];
    } else {
      const lowerQuery = query.toLowerCase();
      this.displayedVariables = this.variables.filter(
        (variable) => variable.key.toLowerCase().includes(lowerQuery) || String(variable.value).toLowerCase().includes(lowerQuery)
      );
    }
    this.renderVariableList();
    const countEl = document.querySelector(".variables-count");
    if (countEl) {
      countEl.textContent = `${this.displayedVariables.length}/${this.variables.length} ${this.language === "en" ? "variables" : "variables"}`;
    }
  }
  renderVariableList() {
    this.variableList.empty();
    if (this.displayedVariables.length === 0) {
      const t = getTranslations(this.language);
      const noResults = this.variableList.createEl("div", {
        cls: "no-results",
        text: t.ui.noVariables
      });
      noResults.style.padding = "16px";
      noResults.style.textAlign = "center";
      noResults.style.color = "var(--text-muted)";
      noResults.style.fontStyle = "italic";
      return;
    }
    this.displayedVariables.forEach((variable, index) => {
      const varItem = this.variableList.createEl("div", {
        cls: "variable-item"
      });
      varItem.style.display = "flex";
      varItem.style.padding = "10px 16px";
      varItem.style.cursor = "pointer";
      varItem.style.borderBottom = "1px solid var(--background-modifier-border-hover)";
      varItem.style.transition = "background-color 150ms ease";
      varItem.style.outline = "none";
      const keyEl = varItem.createEl("div", {
        cls: "variable-key",
        text: variable.key
      });
      keyEl.style.flex = "1";
      keyEl.style.fontWeight = "bold";
      keyEl.style.textOverflow = "ellipsis";
      keyEl.style.overflow = "hidden";
      keyEl.style.whiteSpace = "nowrap";
      const valueEl = varItem.createEl("div", {
        cls: "variable-value",
        text: this.formatValue(variable.value)
      });
      valueEl.style.flex = "1";
      valueEl.style.color = "var(--text-muted)";
      valueEl.style.textOverflow = "ellipsis";
      valueEl.style.overflow = "hidden";
      valueEl.style.whiteSpace = "nowrap";
      varItem.tabIndex = 0;
      varItem.setAttribute("data-index", index.toString());
      varItem.addEventListener("focus", () => {
        varItem.style.backgroundColor = "var(--background-modifier-hover)";
        varItem.style.boxShadow = "inset 3px 0 0 0 var(--interactive-accent)";
      });
      varItem.addEventListener("blur", () => {
        varItem.style.backgroundColor = "";
        varItem.style.boxShadow = "none";
      });
      varItem.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          e.stopPropagation();
          this.onChoose(variable);
          this.close();
        } else if (e.key === "ArrowDown") {
          e.preventDefault();
          const nextSibling = varItem.nextElementSibling;
          if (nextSibling && nextSibling.classList.contains("variable-item")) {
            nextSibling.focus();
          }
        } else if (e.key === "ArrowUp") {
          e.preventDefault();
          const prevSibling = varItem.previousElementSibling;
          if (prevSibling && prevSibling.classList.contains("variable-item")) {
            prevSibling.focus();
          } else {
            this.searchInput.focus();
          }
        } else if (e.key === "Escape") {
          e.preventDefault();
          this.close();
        }
      });
      varItem.addEventListener("mouseenter", () => {
        varItem.style.backgroundColor = "var(--background-modifier-hover)";
      });
      varItem.addEventListener("mouseleave", () => {
        if (document.activeElement !== varItem) {
          varItem.style.backgroundColor = "";
        }
      });
      varItem.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.onChoose(variable);
        this.close();
      });
      if (index === this.displayedVariables.length - 1) {
        varItem.style.borderBottom = "none";
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  formatValue(value) {
    if (value === null || value === void 0) return "null";
    if (typeof value === "object") {
      try {
        return JSON.stringify(value).substring(0, 30) + (JSON.stringify(value).length > 30 ? "..." : "");
      } catch (e) {
        return String(value);
      }
    }
    const strValue = String(value);
    return strValue.length > 30 ? strValue.substring(0, 30) + "..." : strValue;
  }
};
